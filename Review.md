Добрый день!

Акуратная работа, хорошо код читается, но следует некоторый рефакторинг провести, а также учесть поведение пользовтеля внутри вашего приложения. Класс Api спроектировали корректно.

## Надо исправить

- Удалите из проекта и HTML файл с массивом карт, он не нужен

- Ошибка из прошлого спринта: откройте попап, вызовите на инпуте ошибку, закройте крестиком, опять откройте -- ошибка и старый текст остались.

- Моковую аватару надо удалить из CSS, ее надо сразу подгружать с сервера.

- См. комментарий в editInfo.js

- Нельзя менять данные на странице до того как сервер вернул ответ. Сначала надо убедиться, что сервер вернул положительный результат, потом менять DOM. То же самое касается и окон попапов -- после сабмита формы сначала опрашиваем сервер, получаем подтверждение операции и только потом попап закрываем и вносим изменения в DOM.

- Протестируйте такой кейс: загрузите страницу, отключите сеть, попробуйте изменить данные пользователя. Попап не должен закрыться, данные на странице поменяться не должны.

- В классе Api catch для ошибок должен быть у каждого метода, который с сервером работает. Причина в том, что мы не знаем обрабатывает ли кто-то ошибки в точке вызова, поэтому класс должен как минимум сам об ошибке сообщить.

- Catch в методе Api должен либо пробрасывать ошибку через throw, либо возвращать промис с ошибкой, потому что в месте вызова метода должно быть четко понятно, что вернул Api -- успешный ответ или ошибку.

- Полученный ответ от метода экземпляра Api тоже нужно принять через then и catch.

Допустим у вас есть метод Api:

~~~
someApiMethod() {
  return fetch(...)
          .then(...)
          .catch(...) // возвращает reject
}
~~~

В точке вызова действуем так:

~~~
api.someApiMethod()
  .then(... что-то рисуем, меняем, закрываем)
  .catch(... ничего не меняем, не закрываем, сообщаем об ошибке)
~~~

## Можно лучше

- Большое количество параметров лучше передвать в метод или в конструктор через деструктуризацию.

Например в коде:
~~~
const newClass = new Class({ windowOne, userForm, popupObj })
~~~
А внутри класса:
~~~
constructor ({ userForm, popupObj, windowOne }) {...}
~~~
И тогда порядок переменных будет неважен, это удобно

## Можно лучше - 2

- Реализовать зум карточек не через фоновое изображение, а через <img> -- это позволит не деформировать пропорции изображения и кнопка закрытия будет рядом, а не на непонятном отдалении.

## Промежуточный итог
Исправьте критические замечания и присылайте на проверку.
